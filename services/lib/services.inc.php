<?php

/*
 * Copyright (C) 2006, 2007, 2008 Alex Lance, Clancy Malcolm, Cybersource
 * Pty. Ltd.
 * 
 * This file is part of the allocPSA application <info@cyber.com.au>.
 * 
 * allocPSA is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at
 * your option) any later version.
 * 
 * allocPSA is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public
 * License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with allocPSA. If not, see <http://www.gnu.org/licenses/>.
*/


/**
*
* This class provides methods for web services to access key parts of
* alloc's functionality.
*
* The inline PHPDoc-style comments, provide information for WSDL_Gen so that
* the alloc.wsdl file can be dynamically generated by running `make soap`.
*
* You must run `make soap` every time modifications are made to this class.
* You MUST ensure that the PHPDoc parameter definitions are correct. 
*
*/

class alloc_services {

  public function __construct($sessID="") {
    global $current_user; 
    $current_user = $this->get_current_user($sessID);
  }

  /** The authenticate function
   * @param string $username
   * @param string $password
   * @return string $sessID
   */
  public function authenticate($username,$password) {
    $person = new person;
    $sess = new Session;
    $row = $person->get_valid_login_row($username,$password); 
    if ($row) {
      $sess->Start($row,false);
      $sess->UseGet();
      $sess->Save();
      return $sess->GetKey();
    } else {
      die("Authentication Failed(1)."); 
    }
  }  

  private function get_current_user($sessID) {
    $sess = new Session($sessID);
    if (!$sess->Started()) {
      die("Authentication Failed(2).");
    } else {
      $person = new person;
      $person->load_current_user($sess->Get("personID"));
      return $person;
    }
  }

  /** The get_task_comments function
   * @param int $taskID
   * @return array $comments
   */
  public function get_task_comments($taskID) {
    //global $current_user; // Always need this :(
    //$current_user = $this->get_current_user($sessID);
    if ($taskID) {
      $task = new task;
      $task->set_id($taskID);
      $task->select();
      return $task->get_task_comments_array();
    }
  }

  /** The add_timeSheetItem_by_task function
   * @param int $taskID
   * @param string $duration
   * @param string $date
   * @param string $comments
   * @return array $timeSheetID
   */
  public function add_timeSheetItem_by_task($taskID, $duration, $date="", $comments="") {
    //global $current_user; // Always need this :(
    //$current_user = $this->get_current_user($sessID);
    $rtn = timeSheet::add_timeSheetItem_by_task($taskID, $duration, $comments, null, $date);
    if ($rtn["timeSheetItem_save_error"]) {
      die($rtn["timeSheetItem_save_error"]);
    } 
    return $rtn;
  }

  /** The add_timeSheetItem_by_project function
   * @param int $projectID
   * @param string $duration
   * @param string $date
   * @param string $comments
   * @return array $timeSheetID
   */
  public function add_timeSheetItem_by_project($projectID, $duration, $date="", $comments="") {
    //global $current_user; // Always need this :(
    //$current_user = $this->get_current_user($sessID);
    return timeSheet::add_timeSheetItem_by_project($projectID, $duration, $comments, null, $date);
  }

   /** The change_timeSheet_status function
   * @param int $timeSheetID
   * @param string $direction
   * @return int $timeSheetID
   */
  public function change_timeSheet_status($timeSheetID,$direction) {
    $timeSheet = new timeSheet();
    $timeSheet->set_id($timeSheetID);
    $timeSheet->select();
    return $timeSheet->change_status($direction);
  }

 

  /** The get_list function
   * @param string $entity
   * @param mixed $options
   * @return array $list
   */
  public function get_list($entity, $options=array()) {
    global $current_user; // Always need this :(
    //$current_user = $this->get_current_user($sessID);
    if (class_exists($entity)) {
      $options = obj2array($options);
      $e = new $entity;
      if (method_exists($e, "get_list")) {
        ob_start();
        $rtn = $e->get_list($options);
        $echoed = ob_get_contents();
        if (!$rtn && $echoed) {
          return array("error"=>$echoed);
        } else {
          if (isset($rtn["rows"])) {
            return $rtn["rows"];
          } else {
            return $rtn;
          }
        }
      } else {
        die("Entity method '".$entity."->get_list()' does not exist."); 
      }
    } else {
      die("Entity '".$entity."' does not exist."); 
    }
  }

  public function search_emails($str) {
    if ($str) {
      $uids = $this->get_comment_email_uids_search($str);
      foreach ((array)$uids as $uid) {
        $emails.= $this->get_email($uid);
      }
    }
    return $emails;
  }

  public function init_email_info() {
    global $current_user; // Always need this :(
    $info["host"] = config::get_config_item("allocEmailHost");
    $info["port"] = config::get_config_item("allocEmailPort");
    $info["username"] = config::get_config_item("allocEmailUsername");
    $info["password"] = config::get_config_item("allocEmailPassword");
    $info["protocol"] = config::get_config_item("allocEmailProtocol");
    if (!$info["host"]) {
      die("Email mailbox host not defined, assuming email fetch function is inactive.");
    }
    return $info;
  }

  /** The get_email function
   * @param string $sessID
   * @param string $emailUID
   * @return string $email
   */
  public function get_email($emailUID) {
    global $current_user; // Always need this :(
    //$lockfile = ATTACHMENTS_DIR."mail.lock.person_".$current_user->get_id();
    if ($emailUID) {
      $info = $this->init_email_info();
      $mail = new alloc_email_receive($info);
      $mail->open_mailbox(config::get_config_item("allocEmailFolder"),OP_HALFOPEN+OP_READONLY);
      list($header,$body) = $mail->get_raw_email_by_msg_uid($emailUID);
      $mail->close();
      $m = new alloc_email();
      $m->set_headers($header);
      $timestamp = $m->get_header('Date');
      $str = "From allocPSA ".date('D M  j G:i:s Y',strtotime($timestamp))."\r\n".$header.$body;
      return utf8_encode(str_replace("\r\n","\n",$str));
    }
  }

  public function get_comment_email_uids_search($str) {
    if ($str) { 
      global $current_user; // Always need this :(
      //$lockfile = ATTACHMENTS_DIR."mail.lock.person_".$current_user->get_id();
      $info = $this->init_email_info();
      $mail = new alloc_email_receive($info);
      $mail->open_mailbox(config::get_config_item("allocEmailFolder"),OP_HALFOPEN+OP_READONLY);
      $rtn = $mail->get_emails_UIDs_search($str);
      $mail->close();
    }
    return (array)$rtn;
  }

  /** The get_help function
   * @param string $topic
   * @return string $helptext
   */
  public function get_help($topic="") {
    $this_methods = get_class_methods($this);

    if (!$topic) {
      foreach ($this_methods as $method) {
        $m = $method."_help";
        if (method_exists($this,$m)) {
          $available_topics.= $commar.$method;
          $commar = ", ";
        }
      }
      die("Help is available for the following methods: ".$available_topics);

    } else {
      $m = $topic."_help";
      if (method_exists($this,$m)) {
        return $this->$m();
      } else {
        die("No help exists for this method: ".$topic); 
      }
    }
  }

  public function save_interestedParty($options) {
    // Python will submit None instead of ''
    foreach ($options as $k=>$v) { strtolower($v) != 'none' and $data[$k] = $v; }

    // Check we have the minimum of fields
    if ($data["entity"] && $data["entityID"] && $data["emailAddress"]) {
      interestedParty::delete_interested_party($data["entity"],$data["entityID"],$data["emailAddress"]);
      interestedParty::add_interested_party($data);
    }
  }

  public function delete_interestedParty($options) {
    // Python will submit None instead of ''
    foreach ($options as $k=>$v) { strtolower($v) != 'none' and $data[$k] = $v; }

    // Delete existing entries
    if ($data["entity"] && $data["entityID"] && $data["emailAddress"]) {
      interestedParty::delete_interested_party($data["entity"],$data["entityID"],$data["emailAddress"]);
    }
  }

  /** The help function for get_list
   * @return string $helptext
   */
  private function get_list_help() {
    # This function does not require authentication.
    #global $current_user; // Always need this :(
    #$current_user = $this->get_current_user($sessID);

    global $modules;
    foreach ($modules as $name => $object) {  
      if (is_object($object) && is_array($object->db_entities)) {
        foreach ($object->db_entities as $entity) {
          unset($commar2);
          if (class_exists($entity)) {
            $e = new $entity;
            if (method_exists($e, "get_list")) {
              $rtn.= "\n\nEntity: ".$entity."\nOptions:\n";
              if (method_exists($e, "get_list_vars")) {
                $options = $e->get_list_vars();
                foreach ($options as $option=>$help) {
                  $padding = 30 - strlen($option);
                  $rtn.= $commar2."    ".$option.str_repeat(" ",$padding).$help;
                  $commar2 = "\n";
                }
              }
            }
          }
        }
      }
    }
    die("Usage: get_list(entity, options). The following entities are available: ".$rtn);
  }



} 


?>
