<html>
  <body>
    <h1>Alloc Developer Docs</h1>

    <strong>Last updated 2002-02-22 by clancy@cyber.com.au</strong>

    <h2>Project Configuration</h2>

    <table border="1">
      <tr>
        <td>Project manager/senior developer</td>
        <td>Clancy Malcolm</td>
      </tr>
      <tr>
        <td>CVS repository location</td>
        <td>fs:/cyber/devel/cvs/alloc
      </tr>
      <tr>
        <td>Database server</td>
        <td>MySQL on garlic</td>
      </tr>
      <tr>
        <td>Database name</td>
        <td>alloc</td>
      </tr>
    </table>
      
    <h2>Developer Prerequisites</h2>

    In order to be able to develop Alloc, developers should have the following knowledge:
    <ul>
      <li>MySQL SQL queries (including table join syntax)
      <li>HTML
      <li>PHP programming (including functions, objects and regular expressions)
      <li>Common security holes in PHP applications and how to avoid them.
      <li>CVS
    </ul>

    <h2>Code Architecture</h2>

    <h3>alloc.inc</h3>
    <p>The alloc.inc file is a core file of alloc.  The file contains installation specific parameters including database settings and information on which modules should be enabled.  Its location is installation specific, but it must be located somewhere in your PHP include_path (see the PHP documentation for more information on the include_path configuration variable).</p>
    <p>A sample alloc.inc file is shown below:</p>
    <pre>
FIXME: put alloc.inc here
    </pre>
FIXME: Describe contents of alloc.inc here

    <h3>Modules</h3>
    <p>Alloc consists of a number of modules.  Modules are groups of functionality that can be deployed independently.  For example, the finance module can be deployed on a intranet server while the project module can be deployed on an Internet server.  Modules may rely on other modules (e.g. the project module requires the person module).</p>

    <h4>Directory Structure</h4>
    <p>Each module has its own subdirectory under the main alloc directory with the same name as the module.  Each module's subdirectory contains the following subdirectories:
      <ul>
        <li>lib - Library files used by the module.  Files in this directory typically define classes and functions available throughout the module.  This directory must also contain the module's init.php file discussed below.
        <li>templates - HTML templates used by the module (see the templates section below).
        <li>help - The module's help files.
      </ul>
      PHP scripts invoked by the web server are placed directly in the module's subdirectory.</p>


    <h4>The Module Initialization File and Module Class</h4>
    <p>A special file named init.php must be placed in the module's lib directory.  Each module's init.php is loaded at the start of each request.  The file has two purposes.  Firstly it defines the module class - a special class that allows the core alloc code to enquire about a modules features.  Secondly it is responsible for including the module's other library files.  The init.php file for a module named "announcement" is shown below.</p>

    <pre>
&lt;?php
  class announcement_module extends module {
    var $db_entities = array("announcement");

    function register_toolbar_items() {
      if (have_entity_perm("announcement", PERM_READ_WRITE)) {
        register_toolbar_item("announcementList", "Announcements");
      }
    }

    function register_home_items() {
      global $MOD_DIR;

      include("$MOD_DIR/announcement/lib/announcements_home_item.inc.php");
      register_home_item(new announcements_home_item());
    }
  }

  include("$MOD_DIR/announcement/lib/announcement.inc.php");
?&gt;
    </pre>

    <p>The announcement module is a relatively simple module.  It contains one database entity, shows an item on the toolbar, shows an item on the home page and includes one library file.  The module class can also receive event notifications, but this feature has not been used by the announcement module.  In the following sections we will discuss each of these concepts in detail.

    <h4>Module Registration</h4>

    <p>Modules are registered using the alloc.inc file.  See the separate section on alloc.inc for more information.</p>
    
    <h3>Page Files</h3>
    <p>Page files are those files that can be invoked directly by the web server.  A separate file is used for each different page that a module can present to the user.  For example, the announcement module has two page files - announcement.php and announcementList.php.  The announcement.php file shows a form for editing or creating new announcements.  The announcementList.php page file shows a list of all the announcements in the system so that the user can select which announcement they would like to edit.</p>
    <p>Page files typically perform the following tasks:</p>
    <ol>
      <li>Invoke shared code to initialise the request.  This code loads the libraries and checks that the user is authenticated.
      <li>Process any data submitted from the previous page (e.g. if the user submitted an updated announcement then these updates must be saved to the database).  After processing the data the page may choose to redirect to a different page.
      <li>Provide functions to load data for displaying on the page
      <li>Invoke the page's main template.
      <li>Invoke shared code to close the request.  This code performs clean-up functions like writing session data to the database.
    </ol>

    <p>An example of a simple page file is shown below:</p>
    <pre>
&lt;?php
  // initialise the request
  include("alloc.inc");

  // create an object to hold an announcement
  $announcement = new announcement;

  // load the announcement from the database
  if (isset($announcementID)) {
    $announcement-&gt;set_id($announcementID);
    $announcement-&gt;select();
  }

  // read announcement variables set by the request
  $announcement-&gt;read_globals();

  // process submission of the form using the save button
  if (isset($save)) {
    $announcement-&gt;set_value("personID", $current_user-&gt;get_id());
    $announcement-&gt;save();

  // process submission of the form using the delete button
  } else if (isset($delete)) {
    $announcement-&gt;delete();
    page_close();
    header("Location: " . $TPL["url_alloc_announcementList"]);
    exit();
  }

  // load data for display in the template
  $announcement-&gt;set_tpl_values();

  // invoke the page's main template
  include_template("templates/announcementM.tpl");


  // Close the request
  page_close();
?&gt;
    </pre>

    <p>While the body components of the page may be altered to suit the page's purpose, it is critical that the request initialization and closing statements are included in every page.  Without these statements the initialization and authentication procedures cannot operate properly.</p>


    <h3>Library Files</h3>
    <p>Library files are used by modules to provide shared classes, functions and constants.  Library files can be any PHP script providing that they do not output any content when they are first included.  If a library file outputs content (e.g. using the echo statement) then a page cannot output headers after the libraries have been included.  Additionally it is good practice for all content to be outputted using templates anyway.  Generally library files should be limitted to defining constants using the define function, defining functions and defining classes.</p>


    <h3>Database Interfaces</h3>

    Alloc contains a number of classes for making database access easy, powerful and more secure.

    <h4>Database Entities</h4>

    <p>Database entity classes define objects that represent a single record in the database.  Each table has its own database entity class that extends the db_entity class.  For example the announcement module defines an announcement entity as follows:</p>

    <pre>
&lt;?php
  class announcement extends db_entity
  {
    var $data_table = "announcement";

    function announcement() {
      $this-&gt;db_entity();
      $this-&gt;key_field = new db_text_field("announcementID");
      $this-&gt;data_fields = array("heading" =&gt; new db_text_field("heading")
             , "body" =&gt; new db_text_field("body")
             , "personID" =&gt; new db_text_field("personID")
             , "displayFromDate" =&gt; new db_text_field("displayFromDate")
             , "displayToDate" =&gt; new db_text_field("displayToDate")
               );
    }
  }
?&gt;
    </pre>

    <p>Note that it is assumed that the entity class has the same name as the database table.  Also, it is convention to store this script using the file module_name/lib/entity_name.inc.php</p>

    <p>Useful methods of the db_entity class include:</p>
    <ul>
      <li>set_tpl_values() - sets template variables for the entities fields
      <li>read_globals() - set the field values from global variables
      <li>get_value($field_name) - get the value of a field
      <li>set_value($field_name) - set the value of a field
      <li>get_id() - get the entities unique identifier
      <li>set_id() - set the entities unique identifier
      <li>select() - read the record from the database
      <li>save() - write the record to the database
      <li>delete() - delete the record from the database
    </ul>

    <p>FIXME: Add a more thorough explanation of the db_entity class here.</p>

    <h4>Database Filters</h4>

    <p>Filters are classes that allow a list of entities to be filtered by criteria entered by the user or entered by the programmer.  Each table that uses filters must have its own filter class that defines the criteria that can be applied.  Filters extend the db_filter class.</p>

    <p>FIXME: Add a more thorough explanation of the db_filter class here.</p>

    <h4>Entity Lists</h4>

    <p>Entity lists are classes that manipulare a list of entities.  Once you have created a filter you can create a list that provides all the entities that match the filter.  Each table that uses lists must have its own list class.  Lists extend the db_list class.</p>

    <p>FIXME: Add a more thorough explanation of the db_list class here.</p>


    <h4>Utility Functions</h4>

    <p>FIXME: explain the utility functions for generating select options and working with database dates here.</p>

    <h4>Direct Database Access</h4>

    <p>While it is better to use the database interfaces discussed above it is also possible to write your own SQL statements and interact with the database directly.  Direct access is facilitated through a subclass of PHPLib's DB_Sql class called db_alloc.  For more information on the DB_Sql class refer to the PHPLib documentation at <a href="http://phplib.sourceforge.net/">the PHPLib web site</a>.


    <h3>Security</h3>
    <p>A separate document, <a href="alloc_secutiy.html">Alloc's Security Design and Implementation</a>, provides a more complete coverage of Alloc's security.  This section provides a brief coverage from a developer's perspective.</p>

    <h4>Security Concepts</h4>
    <p>Alloc's security model is based on users, roles, entities and permissions.</p>

    <p>A user is any external system or person who interacts with Alloc.  Each Alloc user is authenticated using a unique username and a password.  Users must be authenticated before accessing any of Alloc's functionality.</p>
    <p>Users may be assigned roles.  Each user can be assigned none, one or more than one role.  Initially Alloc has three roles: management staff, administration staff and employees.  Additional roles can be created by users who have been granted appropriate permissions.  It is important to remember that some users (e.g. clients) will have accounts that do not have any of these roles.</p>
    <p>Alloc's entities correspond to database tables.  Examples of entities in Alloc include person, tf, transaction, project and task.  Entities are individually identified by unique identifiers.  For example each person entity has a unique person identifier (personID).  Most entities also have a concept of ownership. For example Bob's TF may be 'owned' by himself.  Some entities can be owned by more than one person. For example, if Bob's wife also had an Alloc account she may be added as an owner of Bob's TF so that she can work with the TF in the same way that Bob can.</p>
    <p>Each entity uses a set of standard actions: create, update, read and delete.  If the entity supports the use of events a monitor events action is also automatically added.  Additionally entities can define their own actions, such as an 'approve' action for a timesheet entity.</p>
    <p>A permissions defines what actions a user or role can perform on an entity.  Examples of possible permission definitions include:</p>
    <ul>
      <li>Allow managers to create, update, read and delete any project entity.
      <li>Allow employees to read and update any project entity that they own.
      <li>Do not allow Bob to read the "My Secret Project" project entity.
    </ul>
    <p>Permissions must be assigned a sort key to indicate which permissions have precedence.  If Bob was an manager then the above permissions would have to use a lower sort key for the third permission than the second.  Otherwise Alloc would read the first permission before the third permission and Bob would be able read the "My Secret Project" project.</p>

    <h4>Entity Security Enforcement</h4>
    <p>If you use Alloc's database interface libraries for all database access then entity security enforcement is largely implicit for the writers of pages.  For example if you call the save() method for a new entity and the current user does not have permission to create the entity then an error message is automatically shown to the user and the script is aborted.  However, you may want to define your own permissions when you define your own entities.  

    <h4>Entity Security Checks</h4>
    <p>While security is usually enforced implicitly, often you will want to be able to determine if the current user has a permission for reasons such as hiding navigation to inaccessible screens.  To check if a user has a permission you can call an entity object's have_perm() method or if you are not interested in a paticular entity you can use the have_entity_perm() function.</p>
    <p>FIXME: Add a more thorough explanation of these functions (parameters, return values, etc)</p>

    <h4>Adding Your Own Permissions</h4>
    <p>FIXME: Flesh out an explanation of how to do this</p>
    <ol>
      <li>Define permission constants in your entity's library file.
      <li>Define the permission descriptions in your entity's constructor.
      <li>Add code to call the check_perm method when the user performs the actions.
    </ol>

    <h4>Avoiding Security Holes</h4>

    It can be easy to inadvertantly write insecure code in PHP.  Alloc developers should be familiar with the common mistakes covered in the PHP training slides at /cyber/admin/training/php/session8....sdd. FIXME: Find the complete path name.

    <h3>Templates</h3>

    <p>Alloc includes a template engine.  The use of templates aims to seperate the application presentation from the application logic and storage.  The templates are fragments of standard HTML files with the following additions:</p>
    <ul>
      <li>Dynamic template variables are specified using {a_variable_name}.  This will get replaced with the value of the template variable.
      <li>Functions can be called using the syntax {:a_function_name an_argument}.  This will not be displayed to the user and will cause the specified function to be invoked at this time instead.
      <li>Template files are conventionally named with the .tpl suffix.  Additionally the last letter before the .tpl suffix is conventionally M, R, S representing a main, repeated or section template respectively.
    </ul>

    <p>To set template variables corresponding to an entity's field names use the entity's set_tpl_values() method.  Alternatively, template variables can be set directly using the $TPL global variable which is an associative array.  For example to set a variable named animal to cat use <code>$TPL["animal"] = "cat";</code>.</p>

    <p>Once you have set the template variables, you can process a template using the include_template($template_file_name) function.</p>

    <p>The file shared/global_tpl_values.inc.php defines some template variables that are available throughout the Alloc.  These include variables for all URLs used by Alloc.</p>


    <h3>Toolbar Items</h3>

    <p>Modules can register one or more links for the toolbar.  When Alloc is generating the toolbar it calls the register_toolbar_items() method of each of the modules.  The module classes should override this method and call the register_toolbar_item() function for each link the module wants to display on the toolbar.  The syntax of the register_toolbar_item() function is as follows:<br>
    <code>function register_toolbar_item($tool_name, $label, $url_parameters = "")</code><br>
    The $tool_name parameter is the name of the page to link to.  This should correspond to one of the URLs set in the shared/global_tpl_values.inc.php file without the <code>url_alloc_</code> prefix.  The $label parameter provides the text to be displayed to the user.  The optional $url_parameters parameter specifies any extra data to be added to the parameters of the URL.  This data should only contain valid URL characters.</p>
    <p>The announcement module registers a toolbar item to manage announcements if the user has appropriate permissions.  The code to perform this is shown below.</p>

&lt;?php
  class announcement_module extends module {
    //...

    function register_toolbar_items() {
      if (have_entity_perm("announcement", PERM_READ_WRITE)) {
        register_toolbar_item("announcementList", "Announcements");
      }
    }

    //...
  }

  // ...
?&gt;
    </pre>


    <h3>Home Page Items</h3>
    <p>In order for the home page to provide quick access to information from a number of modules each module can register classes to display content on the home page.  To add a home page item to your module create a library file that contains a class that extends the home_item class.  Your class should have a constructor with no parameters.  This class should call the constructor for the home_item class.  The constructor for thee home_item_class has the following syntax:<br>
    <code>function home_item($name, $label, $module, $template, $width = "standard")</code><br>
    The parameters are as follows:<br>
    <ul>
      <li>$name - an identifier for this home item.  This is currently unused, but could be used in the future to record a users preferences for which home items are dispayed on their home page and in what order.
      <li>$label - the text shown as the title of the home item
      <li>$module - the <b>name</b> of the home item's module as a string.
      <li>$template - the name of the template file for this home item.  This should not include the directory name - this is determined automatically.
      <li>$width - either "standard" or "narrow".  Standard items are shown with approximately 75% of the windows width while narrow items use the remaining 25%.
    </ul></p>

    <p>An example of a home item to show todays date is below.</p>

<pre>
&lt;?php
  class date_home_item extends home_item {
    function date_home_item() {
      home_item::home_item("date", "Today's Date", "home", "dateH.tpl", "narrow");
    }
    
    function show_date() {
      echo date("Y-m-d");
    }
  }
?&gt;
</pre>

    <p>This home item would require a template in the home/templates directory named dateH.tpl (the H is the conventional code for home item templates).  The template is shown below.</p>
<pre>
Today's date is {:show_date}
</pre>

    <p>While a template variable could be used to display the date this example uses a function to illustrate an important point - functions called from within home items must be defined within their class.  So in this case the show_date() function is inside the date_home_item class.</p>

    <p>There is one more step before our home item is complete - the module class must register the home item when the home page is being displayed.  To register the home_item we override the module's register_home_items method and call the register_home_item function from within it.  The register_home_site function takes a single parameter - the home item object to be registered.  An example of registering a home item is shown below.</p>

<pre>
&lt;?php
  class home_module extends module {
    //...

    function register_home_items() {
      global $MOD_DIR;
      include("$MOD_DIR/home/lib/date_home_item.inc.php");
      register_home_item(new date_home_item);
      //..
    }
  }
?&gt;
</pre>

    <p>Note that the date home item is part of the home module so we have registered it in the home module's class.  If we were writing a home item as part of another module then we would register the home item in that module's class.</p>

    <h3>Event Notifications</h3>

    <p>FIXME: write this section</p>


    <h3>Help Pages</h3>

    <p>FIXME: write this section</p>



  </body>
</html>
